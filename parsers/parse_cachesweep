#!/usr/bin/ruby
require 'fileutils'

$models = %w[timing detailed]
$schemes = %w[none tp open]
$cacheSizes = [0,1,2,4]
$specint = [
    'astar',
    'bzip2',
    'gcc',
    'gobmk',
    'h264ref',
    'hmmer',
    'libquantum',
    'mcf',
    #    'omnetpp',
    #    'perlbench',
    'sjeng',
    'xalan',
].sort

$metrics= {
    "stp" => lambda {|tsp, tmp|
        [tsp,tmp].transpose.map{|x| x.reduce(:/)}.reduce(:+)
    },
    "antt" => lambda {|tsp, tmp|
        [tmp,tsp].transpose.map{|x| x.reduce(:/)}.reduce(:+)
    }
}

def findTimeMP( filename )
    currFile = File.open(filename,'r')
    switchregex = /Switched CPUS/
    lastregex = /Exiting @ tick (\d*) because a thread in cpu(\d*)/ 
    firstregex = /count @ Tick (\d*) because a thread in cpu(\d*)/
    foundcpuswitch = false
    #[p0time, p1time, foundp0, foundp1]
    result = [-1,false,-1,false]
    currFile.each_line do |line|
        if !foundcpuswitch && line.match(switchregex)!=nil
            foundcpuswitch = true
        end
        if line.match(firstregex)!= nil && foundcpuswitch
            time = (line.match firstregex)[1]
            cpu  = (line.match firstregex)[2]
            result[cpu]   = time.to_f
            result[cpu+2] = true
        end
        if line.match(lastregex)!= nil && foundcpuswitch
            time = (line.match lastregex)[1]
            cpu  = (line.match lastregex)[1]
            result[cpu]   = time.to_f
            result[cpu+2] = true
        end
    end
    currFile.close()
    result
end

def findTimeSP( filename )
    currFile = File.open(filename,'r')
    switchregex = /Switched CPUS/
    timeregex = /Exiting @ tick (\d*) because a thread/ 
    time = -1
    currFile.each_line do |line|
        if !foundcpuswitch && line =~ switchregex
            foundcpuswitch = true
        end
        if line =~ timeregex && foundcpuswitch
            time = (line.match timeregex)[1]
        end
    end
    currFile.close()
    time.to_f
end

def build_results( spdir, mpdir, inscount_hash )
    mpdata = $schemes.inject({}){|i,sc|
        i[sc]=$models.inject({}){|j,m|
            j[m]=$cacheSizes.inject({}){|k,c|
                k[c] = $specint.inject({}){|l,p0|
                    l[p0] = $specint.inject({}){|n,p1|
                        n[p1]=[]
                        n }
                    l }
                k }
            j }
        i }

    spdata = $schemes.inject({}){|i,sc|
        i[sc]=$models.inject({}){|j,m|
            j[m]=$cacheSizes.inject({}){|k,c|
                k[c] = $specint.inject({}){|l,p0|
                    l[p0] = $specint.inject({}){|n,p1|
                        n[p1]=[]
                        n }
                    l }
                k }
            j }
        i }

    $schemes.product( $models, $cacheSizes ).each do |scheme, model, cacheSize|
        $specint.combinations(2).each do |p1,p0|
            p0ins = inscount_hash[scheme][model][cacheSize][p0][p1][0]
            p1ins = inscount_hash[scheme][model][cacheSize][p0][p1][1]
            p0FileName = spdir +
                "/stdout_#{scheme}_#{model}_#{p0}_sp#{p0ins}_c#{cacheSize}MB.out"
            p1FileName = spdir +
                "/stdout_#{scheme}_#{model}_#{p1}_sp#{p1ins}_c#{cacheSize}MB.out"
            mpFileName = mpdir +
                "/stdout_#{scheme}_#{model}_#{p0}_#{p1}_c#{cacheSize}MB.out"
            mp0, mp1 = findTimeMP( mpFileName )[0..1]
            sp0 = findTimeSP( p0FileName )
            sp1 = findTimeSP( p1FileName )
            mpdata[scheme][model][cacheSize][p0][p1] = [mp0,mp1]
            spdata[scheme][model][cacheSize][p0][p1] = [sp0,sp1]
        end
    end
    [spdata,mpdata]
end

def setup_outfile( filename )
    file = File.new( filename, 'w' )
    file.printf("%s,%s\n",scheme,model)
    file.printf("%-18s,","workload")
    $cacheSizes.each {|cacheSize| file.printf("%-15s,",cacheSize)}
    file.printf("\n")
end

def save_results( outdir, spdata, mpdata )
    $schemes.product( $models, $metrics.keys ).
        each do |scheme, model, metric|

        outfile = setup_outfile( outdir +
            "/spec_#{metric}_#{scheme}_#{model}.out" )

        $specint.combinations(2).each do |p0,p1|
            outfile.printf("%-18s","#{p0}_#{p1}")
            $cacheSizes.each do |cacheSize|
                tsps  = spdata[scheme][model][cacheSize][p0][p1]
                tmps  = mpdata[scheme][model][cacheSize][p0][p1]
                stat  = $metrics[metric].call(tsps,tmps)
                outfile.printf("%-15.9f\n",stat)
            end
            outfile.printf("\n")
        end
    end
end

if __FILE__ == $0
    spdir = Dir.new(File.expand_path ARGV[0].to_s)
    mpdir = Dir.new(File.expand_path ARGV[1].to_s)

    out_dir = Dir.new(File.expand_path ARGV[2].to_s)
    unless File.directory? perfrep_dir.path
        FileUtils.mkdir_p perfrep_dir.path
    end

    inscount_hash = Marshal.load( File.read "inscount_hash" )
    sp, mp = build_results( spdir, mpdir, inscount_hash )
    save_results( out_dir, sp, mp )

end
